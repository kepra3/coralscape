} else if (metadata$xz[row] > metadata$yz[row]) {
metadata$theta[row] <- metadata$xz[row]
} else {
metadata$theta[row] <- metadata$yz[row]
}
}
# Environmental data ####
# Overhang
overhang_barplot(metadata, metadata$Species)  # Species
overhang_barplot(metadata, metadata$Clusters)  # Cluster
# Theta
k_boxplot(metadata, metadata$Species, metadata$theta) + ggtitle('Theta')
k_boxplot(metadata, metadata$Clusters, metadata$theta) + ggtitle('Theta')
# Relative depth proportion species
k_boxplot(metadata, metadata$Species, metadata$prop) + ggtitle('Outcrop position')
k_boxplot(metadata, metadata$Clusters, metadata$prop) + ggtitle('Outcrop position')
# Z
k_boxplot(metadata, metadata$Species, metadata$z) + ggtitle('Relative depth') # doesn't mean anything for now
k_boxplot(metadata, metadata$Clusters, metadata$z) + ggtitle('Relative depth')
#### Linear Models ####
# 1. overhang #### will become overhang %
metadata$overhang.bin <- ifelse(metadata$overhang == "Yes", 1, 0)
glmer1.overhang <- glmer(overhang ~ Clusters + (1|Loc/Depth), data = metadata, family = binomial) # won't work
# boundary (singular) fit: see ?isSingular - means the random effects don't use too much variation
summary(glmer1.overhang)
emmeans(glmer1.overhang, list(pairwise ~ Clusters), adjust = "tukey")
shapiro.test(metadata$theta) # not normal
lm.theta <- lm(theta ~ Clusters, data = metadata)
summary(lm.theta) # all diff to AA1 except AH2 :D
summary(aov(lm.theta))
TukeyHSD(aov(lm.theta))
k_boxplot(metadata, metadata$Clusters, metadata$theta) + ggtitle('Theta')
# mixed model
lmer1.theta <- lmer(theta ~ Clusters + (1|Loc/Depth), data = metadata)
# boundary (singular) fit: see ?isSingular - means that the random effects don't use too much variation
summary(lmer1.theta)
# extract coefficients
coefs <- data.frame(coef(summary(lmer1.theta)))
# use normal distribution to approximate p-value
coefs$p.z <- 2 * (1 - pnorm(abs(coefs$t.value)))
coefs
# post-hoc
emmeans(lmer1.theta, list(pairwise ~ Clusters), adjust = "tukey")
# including colony size
lmer3.theta <- lmer(theta ~ Clusters * range + (1|Loc/Depth), data = metadata)
summary(lmer3.theta)
coefs <- data.frame(coef(summary(lmer3.theta)))
coefs$p.z <- 2 * (1 - pnorm(abs(coefs$t.value)))
coefs
emmeans(lmer3.theta, list(pairwise ~ Clusters), adjust = "tukey")
# boundary (singular) fit: see ?isSingular - means that the random effects don't use too much variation
summary(lmer2.theta)
summary(lmer3.theta)
coefs <- data.frame(coef(summary(lmer3.theta)))
coefs$p.z <- 2 * (1 - pnorm(abs(coefs$t.value)))
coefs
# including overhang ####
lmer4.theta <- lmer(theta ~ Clusters * range * overhang + (1|Loc/Depth), data = metadata)
# 3. outcrop proportion ####
hist(metadata[metadata$Clusters == "AA1",]$prop)
summary(lmer4.theta)
coefs <- data.frame(coef(summary(lmer4.theta)))
coefs$p.z <- 2 * (1 - pnorm(abs(coefs$t.value)))
coefs
coefs
emmeans(lmer4.theta, list(pairwise ~ Clusters), adjust = "tukey")
# including overhang ####
lmer4.theta <- lmer(theta ~ Clusters * overhang + (1|Loc/Depth), data = metadata)
summary(lmer4.theta)
coefs <- data.frame(coef(summary(lmer4.theta)))
coefs$p.z <- 2 * (1 - pnorm(abs(coefs$t.value)))
coefs
emmeans(lmer4.theta, list(pairwise ~ Clusters), adjust = "tukey")
# including overhang ####
lmer4.theta <- lmer(theta ~ Clusters * as.factor(overhang) + (1|Loc/Depth), data = metadata)
summary(lmer4.theta)
coefs <- data.frame(coef(summary(lmer4.theta)))
coefs$p.z <- 2 * (1 - pnorm(abs(coefs$t.value)))
coefs
emmeans(lmer4.theta, list(pairwise ~ Clusters), adjust = "tukey")
as.factor(overhang)
as.factor(metadata$overhang)
glmer1.overhang <- glmer(overhang.bin ~ Clusters + (1|Loc/Depth), data = metadata, family = binomial) # won't work
# boundary (singular) fit: see ?isSingular - means the random effects don't use too much variation
summary(glmer1.overhang)
emmeans(glmer1.overhang, list(pairwise ~ Clusters), adjust = "tukey")
emmeans(glmer1.overhang, list(pairwise ~ Clusters), adjust = "tukey")
# including overhang ####
lmer4.theta <- lmer(theta ~ Clusters * overhang + (1|Loc/Depth), data = metadata)
summary(lmer4.theta)
coefs <- data.frame(coef(summary(lmer4.theta)))
coefs$p.z <- 2 * (1 - pnorm(abs(coefs$t.value)))
coefs
emmeans(lmer4.theta, list(pairwise ~ Clusters), adjust = "tukey")
cur_kal_20m_20200214_decvis_02_KP_16.12.21_completed <- read.csv("~/Dropbox/agaricia_project_2019/shalo_ag/Photogrammetry/CloudCompare/WP20/cur_kal_20m_20200214_decvis_02_KP_16-12-21_completed.txt", header=FALSE)
View(cur_kal_20m_20200214_decvis_02_KP_16.12.21_completed)
.libPaths()
lib.Paths()
install.packages("dplyr", lib="/Library/Frameworks/R.framework/Versions/4.2/Resources/library")
.libPaths()
install.packages('vcftrs')
install.packages('vctrs')
install.packages("vctrs", lib="/Library/Frameworks/R.framework/Versions/4.2/Resources/library")
install.packages("dplyr", lib="/Library/Frameworks/R.framework/Versions/4.2/Resources/library")
install.packages('dplyr')
library(devtools)
install_github("dandewaters/vcf2ploidy")
library(devtools)
install.packages('usethis')
install.packages('devtools')
library(devtools)
library(usethis)
library(devtools)
detach("package:usethis", unload = TRUE)
install.packages('usethis')
library(usethis)
detach("package:usethis", unload = TRUE)
install.packages('devtools')
sessionInfo()
library(usethis)
update.packages(repos='http://cran.rstudio.com/', ask=FALSE, checkBuilt=TRUE)
library(devtools)
re
remove.packages("usethis")
install.packages("usethis")
library(devtools)
remove.packages(devtools)
remove.packages("devtools")
install.packages("devtools")
library(devtools)
devtools::session_info()
install.packages("fs")
library(devtools)
remove.packages("fs")
install.packages("fs")
library(fs)
library(dplyr)
citation(package="emmeans")
citation(package="vegan")
library(ggplot2)
library(rvg)
library(officer)
p1 <- ggplot(data = mpg, aes(x = manufacturer)) +
geom_bar(stat = 'count') +
geom_text(aes(label = ..count..), stat= "count",  vjust = -0.5) + # adding data labels
theme_minimal() +
labs(title ="My title") +
labs(subtitle ="My subtitle") +
labs(caption ="My caption") +
labs(x ="Car Brand", y = "Count")
p1
dat <- data.frame(x = c(1, 2, 3, 4), y = c(1, 2, 3, 4))
p2 <- ggplot(dat, aes(x, y)) +
geom_abline() +
theme_classic() +
ylab("genetic distance") +
xlab("log(geographic distance)")
p2
install.packages("related")
install.packages("~/Dropbox/My Mac (Katharine’s MacBook Pro)/Downloads/related_1.0.tar.gz", repos = NULL, type = "source")
install.packages("~/Dropbox/My Mac (Katharine’s MacBook Pro)/Downloads/related_1.0.tar.gz", repos = NULL, type = "source")
install.packages("~/Dropbox/related_1.0.tar.gz", repos = NULL, type = "source")
install.packages("~/Dropbox/related_1.0.tar.gz", repos = NULL, type = "source")
gfortran
install.packages("~/Dropbox/related_1.0.tar.gz", repos = NULL, type = "source")
install.packages("~/Dropbox/related_1.0.tar.gz", repos = NULL, type = "source")
locate gcc
install.packages("~/Dropbox/related_1.0.tar.gz", repos = NULL, type = "source")
install.packages("~/Dropbox/related_1.0.tar.gz", repos = NULL, type = "source")
install.packages('devtools')
install.packages("ggplot2")
install.packages("~/Dropbox/related_1.0.tar.gz", repos = NULL, type = "source")
# Packages ####
library(tidyverse)
library(lme4)
library(emmeans)
library(ggplot2)
library(ggpubr)
library(vegan)
library(MASS)
library(FSA)
library(viridis)
library(report)
library(ggplot2)
# Functions
combine_metadata <- function(struc.complex, taxa, coordinates) {
# match
struc.complex.subset <- subset(struc.complex, sample_name %in% taxa$Individual)
taxa.subset <- subset(taxa, Individual %in% struc.complex.subset$sample_name)
coordinates.subset <- subset(coordinates, X %in% struc.complex.subset$sample_name)
# sort
sorted.taxa.subset <- taxa.subset[order(taxa.subset[,1]),]
sorted.coordinates.subset <- coordinates.subset[order(coordinates.subset[,1]),]
sorted.struc.complex.subset <- struc.complex.subset[order(struc.complex.subset[,2]),]
# check if identiical
cat("\nChecking taxa and struc complex: ", identical(sorted.taxa.subset[,1], sorted.struc.complex.subset[,2]))
cat("\nChecking taxa and coordinates: ", identical(sorted.taxa.subset[,1], sorted.coordinates.subset[,1]))
# Put metadata together
metadata <- cbind(sorted.taxa.subset, sorted.struc.complex.subset[,-c(1,2)], sorted.coordinates.subset[,-1])
return(metadata)
}
fix_angles <- function(angles){
angles_new <- angles
for (i in 1:length(angles)) {
if (angles[i] > 90) {
angles_new[i] <- 180 - angles[i]
} else {
angles_new[i] <- angles[i]
}
}
return(angles_new)}
k_boxplot <- function(df, categorical, continuous, lab, colours, facet="No") {
categorical <- droplevels(categorical)
present_taxa <- levels(categorical)
sample.sizes <- NA
for (i in 1:length(present_taxa)) {
sample.sizes[i] <- length(categorical[categorical == present_taxa[i]])
}
if (facet == "All") {
p <- ggplot(df, aes(x = categorical, y = continuous, fill = categorical)) +
geom_boxplot(fill = NA) +
geom_point(size = 2, shape = 21) +
#scale_x_discrete(labels = label) +
scale_fill_manual(name = "Taxa", values = colours,
label = present_taxa) +
theme_classic(base_size = 10) +
ylab(lab) +
xlab('Taxa') +
facet_wrap(~ Depth + Loc, nrow = 1)
} else if (facet == "Depth") {
p <- ggplot(df, aes(x = categorical, y = continuous, fill = categorical)) +
geom_boxplot(fill = NA) +
geom_point(size = 2, shape = 21) +
#scale_x_discrete(labels = label) +
scale_fill_manual(name = "Taxa", values = colours,
label = present_taxa) +
theme_classic(base_size = 10) +
ylab(lab) +
xlab('Taxa') +
facet_wrap(~ Depth)
} else if (facet == "Loc") {
p <- ggplot(df, aes(x = categorical, y = continuous, fill = categorical)) +
geom_boxplot(fill = NA) +
geom_point(size = 2, shape = 21) +
#scale_x_discrete(labels = label) +
scale_fill_manual(name = "Taxa", values = colours,
label = present_taxa) +
theme_classic(base_size = 10) +
ylab(lab) +
xlab('Taxa') +
facet_wrap(~ Loc)
} else {
label = paste0(present_taxa, "\n n = ", sample.sizes)
p <- ggplot(df, aes(x = categorical, y = continuous, fill = categorical)) +
geom_boxplot(fill = NA) +
geom_point(size = 2, shape = 21) +
scale_x_discrete(labels = label) +
scale_fill_manual(name = "Taxa", values = colours,
label = present_taxa) +
theme_classic(base_size = 10) +
ylab(lab) +
xlab('Taxa') }
return(p)
}
overdisp_fun <- function(model) {
rdf <- df.residual(model)
rp <- residuals(model,type="pearson")
Pearson.chisq <- sum(rp^2)
prat <- Pearson.chisq/rdf
pval <- pchisq(Pearson.chisq, df=rdf, lower.tail=FALSE)
c(chisq=Pearson.chisq,ratio=prat,rdf=rdf,p=pval)
}
mds_plot <- function(dat, cent, taxa.colours, ef.data) {
plot <- ggplot() +
geom_point(data = dat, aes(x = MDS1, y = MDS2, fill = Taxa, shape = Taxa), size = 1.5, alpha = 0.5) +
geom_point(data = cent, aes(NMDS1, NMDS2, fill = Taxa, shape = Taxa), size = 3) +
geom_point(data = cent, aes(NMDS1, NMDS2), size = 3, shape = 8, colour = "black") +
scale_fill_manual(values = taxa.colours, name = "Taxa") +
scale_shape_manual(values = c(22, 24), name = "Taxa") +
#coord_fixed() + ## need aspect ratio of 1
ylim(c(-4.5, 4.5)) +
xlim(c(-4.5, 4.5)) +
#ggtitle(paste("Stress: ", round(nmds$stress, digits = 3))) +
theme_minimal() +
geom_segment(data = ef.data, aes(x = 0, xend = NMDS1, y = 0, yend = NMDS2),
arrow = arrow(length = unit (0.25, "cm")), color = "blue") +
geom_text(data = ef.data, aes(x = NMDS1, y = NMDS2, label = row.names(ef.data)),
colour = "blue", size = 3) +
theme(legend.position = "none",
text = element_text(size = 8),
panel.border = element_rect(colour = "black", fill = NA),
axis.ticks = element_line(),
axis.text = element_text(size = 8))
return(plot)
}
# Import datasets
setwd("~/git/coralscape/results/microhabitat_paper_results/")
# Combine
#metadata <- combine_metadata(struc.complex, taxa, coordinates)
#rm(taxa, coordinates, struc.complex)
#write.csv(metadata, "all_metadata_14-6-22.csv", quote = FALSE, row.names = FALSE)
metadata <- read.csv("all_metadata_14-6-22.csv")
# Remove admixed individuals
metadata <- metadata[!metadata$Taxa == "admixed",]
# Structure ####
str(metadata)
#AA1        #AA2        #AH1       #AH2      #AH3      #AL1      #AL2
colours <- c("#274e13","#8fce00", "#b06100", "#ffa500", "#ff4e00", "#6f0641", "#7223f0")
metadata$Depth[metadata$Depth == "10"] <- "10-12"
metadata$Depth[metadata$Depth == "12"] <- "10-12"
metadata$Depth <- factor(metadata$Depth, levels = c("5", "10-12", "20"))
metadata$Loc <- factor(metadata$Loc, levels = c("WP", "SB", "CA", "SQ"))
metadata$Site <- factor(metadata$Site, levels = c("WP05", "CA05", "SB05", "SQ05",
"WP10", "CA10", "SB10", "SQ12",
"WP20", "CA20", "SB20", "SQ20"))
metadata[, c(2, 4:6)] <- data.frame(lapply(metadata[, c(2, 4:6)], as.factor))
metadata$colony_points <- as.integer(metadata$colony_points)
metadata[, 8:15] <- data.frame(lapply(metadata[, 8:15], as.numeric))
str(metadata)
# Transformations ####
metadata$environment_rugosity_sqrt <- sqrt(metadata$environment_rugosity)
metadata$ground_elevation_corr <- fix_angles(metadata$ground_elevation)
# Fix values were overhang was greater than colony
metadata$overhang_prop_2 <- NA
for (i in 1:length(metadata$overhang_prop)) {
if (metadata$overhang_prop[i] > 1) {
metadata$overhang_prop_2[i] <- 1
} else {
metadata$overhang_prop_2[i] <- metadata$overhang_prop[i]
}
}
# Misassignments ####
to_remove <- NA
# Individuals that assigned to LM but are AC or HU
to_remove <- c("KP0529_LM_WP20", "KP0639_LM_SB20", "KP0399_LM_WP20", "KP0583_LM_WP20")
# Individuals that assigned to AC but are LM (or HU)
to_remove <- append(to_remove, c("KP0765_AC_WP10", "KP0851_AC_WP10", "KP0108_AC_SB10", "KP0096_AC_SB10"))
# Individual that appears to be AA2, only next one along (771) but assigned to AA1, 590 AA2 but seems like AA1 need to check
to_remove <- append(to_remove, c("KP0769_AC_WP10", "KP0771_AC_WP10", "KP0590_AC_WP20"))
# Funky colony pics, the 650 lamarcki just some adjustment but mostly correct
to_remove <- append(to_remove, c( "KP0650_LM_SB20", "KP0774_AC_WP10", "KP0400_LM_WP20", "KP0350_LM_WP20"))
# Strangely clones with LM
to_remove <- append(to_remove, c("KP0604_AC_SB20"))
metadata <- metadata[!metadata$Individual %in% to_remove,]
site_list <- levels(metadata$Site)
for  (i in site_list) {
metadata$z_scale[metadata$Site == i] <- scale(metadata$z[metadata$Site == i])
}
# Separate by Depths ####
metadata20 <- metadata[metadata$Depth == "20",]
metadata10 <- metadata[metadata$Depth == "10-12" &
(metadata$Taxa == "AA2" |
metadata$Taxa == "AH1" |
metadata$Taxa == "AH3" |
metadata$Taxa == "AL2"),]
metadata5 <- metadata[metadata$Depth == "5",]
# Proportion of Taxa by Depth ####
library(corrplot)
tab <- table(metadata$Taxa, metadata$Depth)
# Multi-dimensional niche  ####
## agaricites ####
## create environmental distance matrix
AA_data <- metadata20[metadata20$Taxa == "AA1" | metadata20$Taxa == "AA2",]
env <- AA_data[,c(12, 19, 20, 21, 22)]
env$outcrop_prop <- scale(env$outcrop_prop)
env$outcrop_prop <- env$outcrop_prop + abs(min(env$outcrop_prop))
env$environment_rugosity_sqrt <- scale(env$environment_rugosity_sqrt)
env$environment_rugosity_sqrt <- env$environment_rugosity_sqrt + abs(min(env$environment_rugosity_sqrt))
env$ground_elevation_corr <- scale(env$ground_elevation_corr)
env$ground_elevation_corr <- env$ground_elevation_corr + abs(min(env$ground_elevation_corr))
env$overhang_prop_2 <- scale(env$overhang_prop_2)
env$overhang_prop_2 <-  env$overhang_prop_2+ abs(min(env$overhang_prop_2))
env$z_scale <- env$z_scale + abs(min(env$z_scale))
AA_env_dist_mat <- dist(env)
## fit model
AA_adonis <- adonis2(formula = AA_env_dist_mat ~ AA_data$Taxa, permutations = 999, strata = AA_data$Loc, by = "term")
AA_adonis
names(AA_adonis)
# Plot
nmds <- metaMDS(comm = env, distance = "euclidean", k = 2)
ef <- envfit(nmds, env, permu = 999, strata = AA_data$Loc)
ef.data <- as.data.frame(scores(ef, display = "vectors"))
row.names(ef.data) <- c("outcrop", "rugosity", "elevation", "overhang", "z")
dat <- data.frame(nmds$points)
dat$Taxa <- AA_data$Taxa
# Calculate centroids
scores <- scores(nmds, display = "sites")
cent <- aggregate(scores ~ Taxa, data = dat, FUN = "mean")
# Make plot
ac.mds <- mds_plot(dat, cent, colours[1:2], ef.data)
ac.mds
ggsave(plot = ac.mds, "NMDS_Agaricites.pdf", height = 8, width = 8, units = "cm")
## lamarcki ####
AL_data <- metadata20[metadata20$Taxa == "AL1" | metadata20$Taxa == "AL2",]
env <- AL_data[,c(12, 19, 20, 21, 22)]
env$outcrop_prop <- scale(env$outcrop_prop)
env$outcrop_prop <- env$outcrop_prop + abs(min(env$outcrop_prop))
env$environment_rugosity_sqrt <- scale(env$environment_rugosity_sqrt)
env$environment_rugosity_sqrt <- env$environment_rugosity_sqrt + abs(min(env$environment_rugosity_sqrt))
env$ground_elevation_corr <- scale(env$ground_elevation_corr)
env$ground_elevation_corr <- env$ground_elevation_corr + abs(min(env$ground_elevation_corr))
env$overhang_prop_2 <- scale(env$overhang_prop_2)
env$overhang_prop_2 <-  env$overhang_prop_2+ abs(min(env$overhang_prop_2))
env$z_scale <- env$z_scale + abs(min(env$z_scale))
AL_env_dist_mat <- dist(env)
AL_adonis <- adonis2(formula = AL_env_dist_mat ~ AL_data$Taxa, permutations = 999, strata = AL_data$Loc)
AL_adonis <- adonis2(formula = AL_env_dist_mat ~ AL_data$Taxa,
permutations = 999, strata = AL_data$Loc, by = "terms")
AL_adonis
# the adonis test are identical to the annova.cca of dbrda
# permutational MANOVA
nmds <- metaMDS(env, k=2, distance = "euclidean") # K maybe needs to be 3
ef <- envfit(nmds, env, permu = 999, strata = AL_data$Loc)
ef.data <- as.data.frame(scores(ef, display = "vectors"))
row.names(ef.data) <- c("outcrop", "rugosity", "elevation", "overhang", "z")
dat <- data.frame(nmds$points)
dat$Taxa <- AL_data$Taxa
# Calculate centroids
scores <- scores(nmds, display = "sites")
cent <- aggregate(scores ~ Taxa, data = dat, FUN = "mean")
lm.mds <- mds_plot(dat, cent, colours[6:7], ef.data)
lm.mds
# Plot
ggsave(plot = lm.mds, "NMDS_Lamarcki.pdf", height = 8, width = 8, units = "cm")
mds_plot <- function(dat, cent, taxa.colours, ef.data) {
plot <- ggplot() +
geom_point(data = dat, aes(x = MDS1, y = MDS2, fill = Taxa, shape = Taxa), size = 1.5, alpha = 0.5) +
geom_point(data = cent, aes(NMDS1, NMDS2, fill = Taxa, shape = Taxa), size = 3) +
geom_point(data = cent, aes(NMDS1, NMDS2), size = 3, shape = 8, colour = "black") +
scale_fill_manual(values = taxa.colours, name = "Taxa") +
scale_shape_manual(values = c(22, 24), name = "Taxa") +
#coord_fixed() + ## need aspect ratio of 1
ylim(c(-4.5, 4.5)) +
xlim(c(-4.5, 4.5)) +
#ggtitle(paste("Stress: ", round(nmds$stress, digits = 3))) +
theme_minimal() +
geom_segment(data = ef.data, aes(x = 0, xend = NMDS1, y = 0, yend = NMDS2),
arrow = arrow(length = unit (0.25, "cm")), color = "blue") +
geom_text(data = ef.data, aes(x = NMDS1, y = NMDS2, label = row.names(ef.data)),
colour = "blue", size = 3) +
theme(legend.position = "right",
text = element_text(size = 8),
panel.border = element_rect(colour = "black", fill = NA),
axis.ticks = element_line(),
axis.text = element_text(size = 8))
return(plot)
}
## lamarcki ####
AL_data <- metadata20[metadata20$Taxa == "AL1" | metadata20$Taxa == "AL2",]
env <- AL_data[,c(12, 19, 20, 21, 22)]
env$outcrop_prop <- scale(env$outcrop_prop)
env$outcrop_prop <- env$outcrop_prop + abs(min(env$outcrop_prop))
env$environment_rugosity_sqrt <- scale(env$environment_rugosity_sqrt)
env$environment_rugosity_sqrt <- env$environment_rugosity_sqrt + abs(min(env$environment_rugosity_sqrt))
env$ground_elevation_corr <- scale(env$ground_elevation_corr)
env$ground_elevation_corr <- env$ground_elevation_corr + abs(min(env$ground_elevation_corr))
env$overhang_prop_2 <- scale(env$overhang_prop_2)
env$overhang_prop_2 <-  env$overhang_prop_2+ abs(min(env$overhang_prop_2))
env$z_scale <- env$z_scale + abs(min(env$z_scale))
AL_env_dist_mat <- dist(env)
AL_adonis <- adonis2(formula = AL_env_dist_mat ~ AL_data$Taxa, permutations = 999, strata = AL_data$Loc)
AL_adonis <- adonis2(formula = AL_env_dist_mat ~ AL_data$Taxa,
permutations = 999, strata = AL_data$Loc, by = "terms")
AL_adonis
# the adonis test are identical to the annova.cca of dbrda
# permutational MANOVA
nmds <- metaMDS(env, k=2, distance = "euclidean") # K maybe needs to be 3
ef <- envfit(nmds, env, permu = 999, strata = AL_data$Loc)
ef.data <- as.data.frame(scores(ef, display = "vectors"))
row.names(ef.data) <- c("outcrop", "rugosity", "elevation", "overhang", "z")
dat <- data.frame(nmds$points)
dat$Taxa <- AL_data$Taxa
# Calculate centroids
scores <- scores(nmds, display = "sites")
cent <- aggregate(scores ~ Taxa, data = dat, FUN = "mean")
lm.mds <- mds_plot(dat, cent, colours[6:7], ef.data)
lm.mds
# Plot
ggsave(plot = lm.mds, "NMDS_Lamarcki_leg.pdf", height = 8, width = 8, units = "cm")
# Multi-dimensional niche  ####
## agaricites ####
## create environmental distance matrix
AA_data <- metadata20[metadata20$Taxa == "AA1" | metadata20$Taxa == "AA2",]
env <- AA_data[,c(12, 19, 20, 21, 22)]
env$outcrop_prop <- scale(env$outcrop_prop)
env$outcrop_prop <- env$outcrop_prop + abs(min(env$outcrop_prop))
env$environment_rugosity_sqrt <- scale(env$environment_rugosity_sqrt)
env$environment_rugosity_sqrt <- env$environment_rugosity_sqrt + abs(min(env$environment_rugosity_sqrt))
env$ground_elevation_corr <- scale(env$ground_elevation_corr)
env$ground_elevation_corr <- env$ground_elevation_corr + abs(min(env$ground_elevation_corr))
env$overhang_prop_2 <- scale(env$overhang_prop_2)
env$overhang_prop_2 <-  env$overhang_prop_2+ abs(min(env$overhang_prop_2))
env$z_scale <- env$z_scale + abs(min(env$z_scale))
AA_env_dist_mat <- dist(env)
## fit model
AA_adonis <- adonis2(formula = AA_env_dist_mat ~ AA_data$Taxa, permutations = 999, strata = AA_data$Loc, by = "term")
AA_adonis
names(AA_adonis)
# Plot
nmds <- metaMDS(comm = env, distance = "euclidean", k = 2)
ef <- envfit(nmds, env, permu = 999, strata = AA_data$Loc)
ef.data <- as.data.frame(scores(ef, display = "vectors"))
row.names(ef.data) <- c("outcrop", "rugosity", "elevation", "overhang", "z")
dat <- data.frame(nmds$points)
dat$Taxa <- AA_data$Taxa
# Calculate centroids
scores <- scores(nmds, display = "sites")
cent <- aggregate(scores ~ Taxa, data = dat, FUN = "mean")
# Make plot
ac.mds <- mds_plot(dat, cent, colours[1:2], ef.data)
ac.mds
ggsave(plot = ac.mds, "NMDS_Agaricites_leg.pdf", height = 8, width = 8, units = "cm")
