View(popfile_2b2)
popfile_2b2 <- separate(popfile_2b, V1, sep = "_", into = c('name', 'x'), remove = FALSE, extra = 'merge', from =
"right")
popfile_2b2 <- separate(popfile_2b, V1, sep = "_", into = c('name', 'x'), remove = FALSE, extra = 'merge', fill =
"right")
View(popfile_2b2)
fastqs2 <- separate(fastqs, V1, sep = "[.]", into = c('name', 'x', 'y'))
popfile_2b2 <- separate(popfile_2b, V1, sep = "_", into = c('name', 'x'), remove = FALSE, extra = 'merge', fill =
"left")
View(popfile_2b)
View(popfile_2b2)
View(popfile_2b2)
popfile_2b2 <- separate(popfile_2b, V1, sep = 9, into = c('name', 'x'), remove = FALSE, extra = 'merge', fill =
"left")
View(popfile_2b2)
popfile_2b2 <- separate(popfile_2b, V1, sep = 15, into = c('name', 'x'), remove = FALSE, extra = 'merge', fill =
"left")
View(popfile_2b2)
popfile_2b2 <- separate(popfile_2b, V1, sep = 13, into = c('name', 'x'), remove = FALSE, extra = 'merge', fill =
"left")
View(popfile_2b2)
popfile_2b2 <- separate(popfile_2b, V1, sep = 13, into = c('name', 'x'), extra = 'merge', fill =
"left")
View(popfile_2b2)
check <- fastqs2$name %in% popfile_2b2$name
check
# Packages
library(vcfR)
library(adegenet)
library(ggplot2)
library(lme4)
library(emmeans)
# Functions
combine_metadata <- function(struc.complex, clusters, coordinates) {
# match
struc.complex.subset <- subset(struc.complex, X %in% clusters$Individual)
clusters.subset <- subset(clusters, Individual %in% struc.complex.subset$X)
coordinates.subset <- subset(coordinates, X %in% struc.complex.subset$X)
# sort
sorted.clusters.subset <- clusters.subset[order(clusters.subset[,1]),]
sorted.coordinates.subset <- coordinates.subset[order(coordinates.subset[,1]),]
sorted.struc.complex.subset <- struc.complex.subset[order(struc.complex.subset[,1]),]
# check if identiical
cat("\nChecking clusters and struc complex: ", identical(sorted.clusters.subset[,1], sorted.struc.complex.subset[,1]))
cat("\nChecking clusters and coordinates: ", identical(sorted.clusters.subset[,1], sorted.coordinates.subset[,1]))
# Put metadata together
metadata <- sorted.clusters.subset
metadata[,20:25] <- sorted.struc.complex.subset[,2:7]
metadata[, 26:28] <- sorted.coordinates.subset[,2:4]
return(metadata)
}
overhang_barplot <- function(metadata, factor) {
overhang <- table(metadata$overhang, factor) %>% matrix(nrow = 2, ncol = length(levels(factor)))
colnames(overhang) <- levels(factor)
rownames(overhang) <- levels(metadata$overhang)
barplot(overhang, main = "Presence of overhang", xlab = "Taxa",
col = c("Red", "Green"))
legend("topright", c("No", "Yes"), fill = c("Red", "Green"))
}
k_boxplot <- function(df, cat, cont) {
levels <- levels(cat)
sample.sizes <- NA
for (i in 1:length(levels)) {
sample.sizes[i] <- length(cat[cat == levels[i]])
}
label = paste0(levels, "\n n = ", sample.sizes)
p <- ggplot(df, aes(x = cat, y = cont)) +
geom_boxplot(notch = TRUE) +
geom_point(size = 3, shape = 1) +
scale_x_discrete(labels = label) +
theme_classic(base_size = 12)
return(p)
}
# Import datasets
struc.complex <- read.csv("~/git/coralscape_open3d/results/sample_metadata.csv")
clusters <- read.csv("~/Dropbox/agaricia_project_2019/shalo_ag/gen_project/data/all-aga_1d_nc_20_6.csv")
# Import datasets
struc.complex <- read.csv("~/git/coralscape/results/sample_metadata.csv")
clusters <- read.csv("~/Dropbox/agaricia_project_2019/shalo_ag/gen_project/data/all-aga_1d_nc_20_6.csv")
coordinates <- read.csv("~/git/coralscape/results/annotations.csv")
# Organise data
metadata <- combine_metadata(struc.complex, clusters, coordinates)
# Clean working space
rm(struc.complex)
rm(clusters)
rm(coordinates)
# Data structure
str(metadata)
metadata[, c(2:6, 13, 24)] <- data.frame(lapply(metadata[, c(2:6, 13, 24)], as.factor))
levels(metadata$Clusters) <- c("AA1", "AL2", "AH1", "AA2", "AL1","AH2")
str(metadata)
# choosing steepest angle
metadata$theta <- NA
for (row in 1:length(metadata$xz)) {
if (is.na(metadata$xz[row])) {
next
} else if (is.na(metadata$yz[row])) {
next
} else if (metadata$xz[row] > metadata$yz[row]) {
metadata$theta[row] <- metadata$xz[row]
} else {
metadata$theta[row] <- metadata$yz[row]
}
}
# Environmental data ####
# Overhang
overhang_barplot(metadata, metadata$Species)  # Species
overhang_barplot(metadata, metadata$Clusters)  # Cluster
# Theta
k_boxplot(metadata, metadata$Species, metadata$theta) + ggtitle('Theta')
k_boxplot(metadata, metadata$Clusters, metadata$theta) + ggtitle('Theta')
# Relative depth proportion species
k_boxplot(metadata, metadata$Species, metadata$prop) + ggtitle('Outcrop position')
k_boxplot(metadata, metadata$Clusters, metadata$prop) + ggtitle('Outcrop position')
# Z
k_boxplot(metadata, metadata$Species, metadata$z) + ggtitle('Relative depth') # doesn't mean anything for now
k_boxplot(metadata, metadata$Clusters, metadata$z) + ggtitle('Relative depth')
#### Linear Models ####
# 1. overhang #### will become overhang %
metadata$overhang.bin <- ifelse(metadata$overhang == "Yes", 1, 0)
glmer1.overhang <- glmer(overhang ~ Clusters + (1|Loc/Depth), data = metadata, family = binomial) # won't work
# boundary (singular) fit: see ?isSingular - means the random effects don't use too much variation
summary(glmer1.overhang)
emmeans(glmer1.overhang, list(pairwise ~ Clusters), adjust = "tukey")
shapiro.test(metadata$theta) # not normal
lm.theta <- lm(theta ~ Clusters, data = metadata)
summary(lm.theta) # all diff to AA1 except AH2 :D
summary(aov(lm.theta))
TukeyHSD(aov(lm.theta))
k_boxplot(metadata, metadata$Clusters, metadata$theta) + ggtitle('Theta')
# mixed model
lmer1.theta <- lmer(theta ~ Clusters + (1|Loc/Depth), data = metadata)
# boundary (singular) fit: see ?isSingular - means that the random effects don't use too much variation
summary(lmer1.theta)
# extract coefficients
coefs <- data.frame(coef(summary(lmer1.theta)))
# use normal distribution to approximate p-value
coefs$p.z <- 2 * (1 - pnorm(abs(coefs$t.value)))
coefs
# post-hoc
emmeans(lmer1.theta, list(pairwise ~ Clusters), adjust = "tukey")
# including colony size
lmer3.theta <- lmer(theta ~ Clusters * range + (1|Loc/Depth), data = metadata)
summary(lmer3.theta)
coefs <- data.frame(coef(summary(lmer3.theta)))
coefs$p.z <- 2 * (1 - pnorm(abs(coefs$t.value)))
coefs
emmeans(lmer3.theta, list(pairwise ~ Clusters), adjust = "tukey")
# boundary (singular) fit: see ?isSingular - means that the random effects don't use too much variation
summary(lmer2.theta)
summary(lmer3.theta)
coefs <- data.frame(coef(summary(lmer3.theta)))
coefs$p.z <- 2 * (1 - pnorm(abs(coefs$t.value)))
coefs
# including overhang ####
lmer4.theta <- lmer(theta ~ Clusters * range * overhang + (1|Loc/Depth), data = metadata)
# 3. outcrop proportion ####
hist(metadata[metadata$Clusters == "AA1",]$prop)
summary(lmer4.theta)
coefs <- data.frame(coef(summary(lmer4.theta)))
coefs$p.z <- 2 * (1 - pnorm(abs(coefs$t.value)))
coefs
coefs
emmeans(lmer4.theta, list(pairwise ~ Clusters), adjust = "tukey")
# including overhang ####
lmer4.theta <- lmer(theta ~ Clusters * overhang + (1|Loc/Depth), data = metadata)
summary(lmer4.theta)
coefs <- data.frame(coef(summary(lmer4.theta)))
coefs$p.z <- 2 * (1 - pnorm(abs(coefs$t.value)))
coefs
emmeans(lmer4.theta, list(pairwise ~ Clusters), adjust = "tukey")
# including overhang ####
lmer4.theta <- lmer(theta ~ Clusters * as.factor(overhang) + (1|Loc/Depth), data = metadata)
summary(lmer4.theta)
coefs <- data.frame(coef(summary(lmer4.theta)))
coefs$p.z <- 2 * (1 - pnorm(abs(coefs$t.value)))
coefs
emmeans(lmer4.theta, list(pairwise ~ Clusters), adjust = "tukey")
as.factor(overhang)
as.factor(metadata$overhang)
glmer1.overhang <- glmer(overhang.bin ~ Clusters + (1|Loc/Depth), data = metadata, family = binomial) # won't work
# boundary (singular) fit: see ?isSingular - means the random effects don't use too much variation
summary(glmer1.overhang)
emmeans(glmer1.overhang, list(pairwise ~ Clusters), adjust = "tukey")
emmeans(glmer1.overhang, list(pairwise ~ Clusters), adjust = "tukey")
# including overhang ####
lmer4.theta <- lmer(theta ~ Clusters * overhang + (1|Loc/Depth), data = metadata)
summary(lmer4.theta)
coefs <- data.frame(coef(summary(lmer4.theta)))
coefs$p.z <- 2 * (1 - pnorm(abs(coefs$t.value)))
coefs
emmeans(lmer4.theta, list(pairwise ~ Clusters), adjust = "tukey")
cur_kal_20m_20200214_decvis_02_KP_16.12.21_completed <- read.csv("~/Dropbox/agaricia_project_2019/shalo_ag/Photogrammetry/CloudCompare/WP20/cur_kal_20m_20200214_decvis_02_KP_16-12-21_completed.txt", header=FALSE)
View(cur_kal_20m_20200214_decvis_02_KP_16.12.21_completed)
.libPaths()
lib.Paths()
install.packages("dplyr", lib="/Library/Frameworks/R.framework/Versions/4.2/Resources/library")
.libPaths()
install.packages('vcftrs')
install.packages('vctrs')
install.packages("vctrs", lib="/Library/Frameworks/R.framework/Versions/4.2/Resources/library")
install.packages("dplyr", lib="/Library/Frameworks/R.framework/Versions/4.2/Resources/library")
install.packages('dplyr')
library(devtools)
install_github("dandewaters/vcf2ploidy")
library(devtools)
install.packages('usethis')
install.packages('devtools')
library(devtools)
library(usethis)
library(devtools)
detach("package:usethis", unload = TRUE)
install.packages('usethis')
library(usethis)
detach("package:usethis", unload = TRUE)
install.packages('devtools')
sessionInfo()
library(usethis)
update.packages(repos='http://cran.rstudio.com/', ask=FALSE, checkBuilt=TRUE)
library(devtools)
re
remove.packages("usethis")
install.packages("usethis")
library(devtools)
remove.packages(devtools)
remove.packages("devtools")
install.packages("devtools")
library(devtools)
devtools::session_info()
install.packages("fs")
library(devtools)
remove.packages("fs")
install.packages("fs")
library(fs)
library(dplyr)
# Packages
library(tidyverse)
library(lme4)
library(emmeans)
library(ggplot2)
# Packages
library(tidyverse)
library(lme4)
library(emmeans)
library(ggplot2)
library(vegan)
library(MASS)
# Functions
combine_metadata <- function(struc.complex, clusters, coordinates) {
# match
struc.complex.subset <- subset(struc.complex, sample_name %in% clusters$Individual)
clusters.subset <- subset(clusters, Individual %in% struc.complex.subset$sample_name)
coordinates.subset <- subset(coordinates, X %in% struc.complex.subset$sample_name)
# sort
sorted.clusters.subset <- clusters.subset[order(clusters.subset[,1]),]
sorted.coordinates.subset <- coordinates.subset[order(coordinates.subset[,1]),]
sorted.struc.complex.subset <- struc.complex.subset[order(struc.complex.subset[,2]),]
# check if identiical
cat("\nChecking clusters and struc complex: ", identical(sorted.clusters.subset[,1], sorted.struc.complex.subset[,2]))
cat("\nChecking clusters and coordinates: ", identical(sorted.clusters.subset[,1], sorted.coordinates.subset[,1]))
# Put metadata together
metadata <- cbind(sorted.clusters.subset, sorted.struc.complex.subset[,3:10], sorted.coordinates.subset[,-1])
return(metadata)
}
fix_angles <- function(angles){
angles_new <- angles
for (i in 1:length(angles)) {
if (angles[i] > 90) {
angles_new[i] <- 180 - angles[i]
} else {
angles_new[i] <- angles[i]
}
}
return(angles_new)}
k_boxplot <- function(df, categorical, continuous, lab, colours, facet="No") {
categorical <- droplevels(categorical)
present_clusters <- levels(categorical)
sample.sizes <- NA
for (i in 1:length(present_clusters)) {
sample.sizes[i] <- length(categorical[categorical == present_clusters[i]])
}
if (facet == "All") {
p <- ggplot(df, aes(x = categorical, y = continuous, color = categorical)) +
geom_boxplot(notch = TRUE) +
geom_point(size = 3, shape = 1) +
#scale_x_discrete(labels = label) +
scale_color_manual(name = "Clusters", values = colours,
label = present_clusters) +
theme_classic(base_size = 12) +
ylab(lab) +
xlab('Clusters') +
facet_wrap(~ Depth + Loc)
} else if (facet == "Depth") {
p <- ggplot(df, aes(x = categorical, y = continuous, color = categorical)) +
geom_boxplot(notch = TRUE) +
geom_point(size = 3, shape = 1) +
#scale_x_discrete(labels = label) +
scale_color_manual(name = "Clusters", values = colours,
label = present_clusters) +
theme_classic(base_size = 12) +
ylab(lab) +
xlab('Clusters') +
facet_wrap(~ Depth)
} else if (facet == "Loc") {
p <- ggplot(df, aes(x = categorical, y = continuous, color = categorical)) +
geom_boxplot(notch = TRUE) +
geom_point(size = 3, shape = 1) +
#scale_x_discrete(labels = label) +
scale_color_manual(name = "Clusters", values = colours,
label = present_clusters) +
theme_classic(base_size = 12) +
ylab(lab) +
xlab('Clusters') +
facet_wrap(~ Loc)
} else {
label = paste0(present_clusters, "\n n = ", sample.sizes)
p <- ggplot(df, aes(x = categorical, y = continuous, colour = categorical)) +
geom_boxplot(notch = TRUE) +
geom_point(size = 3, shape = 1) +
scale_x_discrete(labels = label) +
scale_color_manual(name = "Clusters", values = colours,
label = present_clusters) +
theme_classic(base_size = 12) +
ylab(lab) +
xlab('Clusters') }
return(p)
}
k_rda <- function(env.scale, depth) {
env.scale$Site <- metadata$Site
env.scale$Depth <- metadata$Depth
env.scale.depth <- env.scale[env.scale$Depth == depth,]
# see relationships
pairs(env.scale.depth, lower.panel = NULL, col = as.numeric(env.scale.depth$Clusters))
rda <- rda(env.scale.depth[,-c(5,6,7)], scale = TRUE)
#make plot
biplot(rda,
display = c("sites",
"species"),
type = c("text",
"points"))
#Add "hulls"
env.scale.depth$Clusters <- droplevels(env.scale.depth$Clusters)
cluster.depth.names <- levels(env.scale.depth$Clusters)
ordihull(rda,
group = env.scale.depth$Clusters, col = rep(1:length(cluster.depth.names)))
legend("topleft",
col = rep(1:length(cluster.depth.names)),
lty = 1,
legend = cluster.depth.names)
title(paste("PCA", depth, "m"))
colvec <- rep(1:length(cluster.depth.names))
with(env.scale.depth, points(rda, display = "sites", col = colvec[Clusters], pch = 21, bg = colvec[Clusters]))
#scores <- data.frame(rda$CA$u)
#scores$group <- env.scale.depth$Clusters
#pca.centroids <- aggregate(scores[,1:4], list(scores[,5]), mean)
#points(pca.centroids$PC1*4, pca.centroids$PC2*4, col = colvec)
print('Displaying plot')
}
k_lda <- function(env.scale.lda, species) {
env.scale.species <- env.scale.lda[env.scale.lda$Clusters == paste0(species, 1) | env.scale.lda$Clusters == paste0(species, 2),]
env.scale.species$Clusters <- droplevels(env.scale.species$Clusters)
env.scale.species.lda <- env.scale.species[,-7]
lda <- lda(formula = Clusters ~ ., data = env.scale.species.lda)
## get the x,y coordinates for the LDA plot
data.lda.values <- predict(lda)
## create a dataframe that has all the info we need to draw a graph
plot.data <- data.frame(X = data.lda.values$x[,1], Clusters = env.scale.species$Clusters, Depth = env.scale.species$Depth)
head(plot.data)
## draw a graph using ggplot2
p <- ggplot(data = plot.data, aes(x = X, y = rep(1:length(X)), color = Clusters)) +
stat_ellipse() +
ylab("Indexes of no relevance") +
xlab("LDA1") +
geom_point(aes(shape = Depth, size = 1.5)) +
theme_bw()
return(p)
}
# Import datasets
setwd("~/git/coralscape/results/")
struc.complex <- read.csv("~/git/coralscape/results/struc_complex_results.txt", sep = "\t")
#struc.complex <- read.csv("~/git/coralscape/results/axis_angle_rotation/struc_complex_results_X.csv")
#clusters <- read.csv("~/Dropbox/agaricia_project_2019/shalo_ag/gen_project/data/all-aga_1d_nc_20_6.csv")
clusters <- read.csv("all-aga_1d_wc_20_4_assigned.csv")
coordinates <- read.csv("~/git/coralscape/results/annotations.csv")
# Combine
metadata <- combine_metadata(struc.complex, clusters, coordinates)
rm(clusters, coordinates, struc.complex)
# Structure
str(metadata)
#metadata$Clusters[metadata$Clusters == 1] = "AA2"
#metadata$Clusters[metadata$Clusters == 2] = "AL2"
#metadata$Clusters[metadata$Clusters == 3] = "AH1"
#metadata$Clusters[metadata$Clusters == 4] = "AA1"
#metadata$Clusters[metadata$Clusters == 5] = "AL1"
#metadata$Clusters[metadata$Clusters == 6] = "AH2"
#metadata$Clusters[metadata$Clusters == 7] = "AH3"
#AA1        #AA2        #AH1       #AH2      #AH3      #AL1      #AL2
colours <- c("#274e13","#8fce00", "#b06100", "#ffa500", "#ff4e00", "#6f0641", "#7223f0")
metadata[, c(2:4, 9)] <- data.frame(lapply(metadata[, c(2:4, 9)], as.factor))
str(metadata)
metadata$colony_rugosity_sqrt <- sqrt(metadata$colony_rugosity)
metadata$environment_rugosity_sqrt <- sqrt(metadata$environment_rugosity)
metadata$colony_elevation_corr <- fix_angles(metadata$colony_elevation)
metadata$ground_elevation_corr <- fix_angles(metadata$ground_elevation)
metadata$overhang_prop_2 <- NA
for (i in 1:length(metadata$overhang_prop)) {
if (metadata$overhang_prop[i] > 1) {
metadata$overhang_prop_2[i] <- 1
} else {
metadata$overhang_prop_2[i] <- metadata$overhang_prop[i]
}
}
area_results <- read.delim("~/git/coralscape/results/area_results.txt")
#area_results_WP20 <- read.delim("~/git/coralscape/results/results_WP20/area_results_WP20.txt")
#area_results <- rbind(area_results, area_results_WP20)
area_results_sub <-  subset(area_results, sample_name %in% metadata$Individual)
area_results_sort <-  area_results_sub[order(area_results_sub[,2]),]
identical(area_results_sort[,2], metadata[,1])
metadata$area <- area_results_sort$colony_threeD_area
area_results_sort <-  area_results_sub[order(area_results_sub[,2]),]
identical(area_results_sort[,2], metadata[,1])
rm(area_results)
rm(area_results_sort)
rm(area_results_sub)
# List of samples to remove due to issues ####
# See sample_investigation.xcls
env <- metadata[, c(18,24,26,27,28,30)]
View(metadata)
View(metadata)
# List of samples to remove due to issues ####
# See sample_investigation.xcls
env <- metadata[, c(18,24,26,27,28)]
env_x <- env
env_x$Clusters <- metadata$Clusters
env_x$Individual <- metadata$Individual
env_x$colony_points <- metadata$colony_points
to_remove <- NA
# Individuals that assigned to LM but are AC or HU
to_remove <- c("KP0529_LM_WP20", "KP0639_LM_SB20", "KP0399_LM_WP20", "KP0583_LM_WP20")
# Individuals that assigned to AC but are LM (or HU)
to_remove <- append(to_remove, c("KP0765_AC_WP10", "KP0851_AC_WP10", "KP0108_AC_SB10", "KP0096_AC_SB10"))
# Indivudal that appears to be AA2, only next one along (771) but assigned to AA1, 590 AA2 but seems like AA1 need to check
to_remove <- append(to_remove, c("KP0769_AC_WP10", "KP0771_AC_WP10", "KP0590_AC_WP20"))
# Funky colony pics, the 650 lamarcki just some adjustment but mostly correct
to_remove <- append(to_remove, c( "KP0650_LM_SB20", "KP0774_AC_WP10", "KP0400_LM_WP20", "KP0350_LM_WP20"))
# Strangely clones with LM
to_remove <- append(to_remove, c("KP0604_AC_SB20"))
# Funky measures
#to_remove <- append(to_remove,(c("KP0293_LM_WP20",)))
metadata <- metadata[!metadata$Individual %in% to_remove,]
env_x <- env_x[!env_x$Individual %in% to_remove,]
env_x$area <- metadata$area
View(metadata)
View(env_x)
env_x$colony_rugosity_sqrt <- metadata$colony_rugosity_sqrt
env_x$colony_rugosity <- metadata$colony_rugosity
env_x$colony_elevation_corr <- metadata$colony_elevation_corr
env_x$overhang_prop_2 <- metadata$overhang_prop_2
env_x$environment_rugosity <- metadata$environment_rugosity
env_x$site <- metadata$Site
# Plots ####
k_boxplot(metadata, metadata$Clusters, metadata$environment_rugosity_sqrt, "Square-root of Environment Rugosity", colours)
k_boxplot(metadata, metadata$Clusters, metadata$environment_rugosity_sqrt, "Square-root of Environment Rugosity", colours, facet = "All")
k_boxplot(metadata, metadata$Clusters, metadata$environment_rugosity_sqrt, "Square-root of Envirosnment Rugosity", colours, facet = "Depth")
#k_boxplot(metadata, metadata$Clusters, metadata$colony_elevation, "Colony Elevation", colours)
#k_boxplot(metadata, metadata$Clusters, metadata$colony_elevation, "Colony Elevation", colours, facet = "All")
#k_boxplot(metadata, metadata$Clusters, metadata$colony_elevation, "Colony Elevation", colours, facet = "Depth")
k_boxplot(metadata, metadata$Clusters, metadata$colony_elevation_corr, "Colony Elevation corr", colours)
k_boxplot(metadata, metadata$Clusters, metadata$colony_elevation_corr, "Colony Elevation corr", colours, facet = "All")
k_boxplot(metadata, metadata$Clusters, metadata$colony_elevation_corr, "Colony Elevation corr", colours, facet = "Depth")
k_boxplot(metadata, metadata$Clusters, metadata$ground_elevation_corr, "Ground Elevation corr", colours)
k_boxplot(metadata, metadata$Clusters, metadata$ground_elevation_corr, "Ground Elevation corr", colours, facet = "All")
k_boxplot(metadata, metadata$Clusters, metadata$ground_elevation_corr, "Ground Elevation corr", colours, facet = "Depth")
k_boxplot(metadata, metadata$Clusters, metadata$colony_rugosity_sqrt, "Square-root of Colony Rugosity", colours)
k_boxplot(metadata, metadata$Clusters, metadata$colony_rugosity_sqrt, "Square-root of Colony Rugosity", colours, facet = "All")
k_boxplot(metadata, metadata$Clusters, metadata$colony_rugosity_sqrt, "Square-root of Colony Rugosity", colours, facet = "Depth")
k_boxplot(metadata, metadata$Clusters, metadata$colony_rugosity, "Colony Rugosity", colours, facet = "Depth")
#k_boxplot(metadata, metadata$Clusters, metadata$overhang_prop, "Overhang prop", colours)
k_boxplot(metadata, metadata$Clusters, metadata$overhang_prop_2, "Overhang proportion", colours)
k_boxplot(metadata, metadata$Clusters, metadata$overhang_prop_2, "Overhang proportion", colours, facet = "All")
k_boxplot(metadata, metadata$Clusters, metadata$overhang_prop_2, "Overhang proportion", colours, facet = "Depth")
k_boxplot(metadata, metadata$Clusters, metadata$outcrop_prop, "Outcrop proportion", colours)
k_boxplot(metadata, metadata$Clusters, metadata$outcrop_prop, "Outcrop proportion", colours, facet = "All")
k_boxplot(metadata, metadata$Clusters, metadata$outcrop_prop, "Outcrop proportion", colours, facet = "Depth")
ggplot(metadata, aes(colony_rugosity, colony_elevation_corr, colour = Clusters)) +
geom_point() + theme_classic()
# Checking normality
shapiro.test(metadata$colony_elevation) # not-normal
shapiro.test(metadata$colony_rugosity_sqrt) # not normal, from 1 to inf
shapiro.test(metadata$environment_rugosity_sqrt) #normal
shapiro.test(metadata$outcrop_prop) # not normal
shapiro.test(metadata$overhang_prop) # not normal, from 0 to 1, zero-inflated
# Elevation ####
lm.colony_elevation <- lm(colony_elevation ~ Clusters, data = metadata)
summary(lm.colony_elevation)
TukeyHSD(aov(lm.colony_elevation))
lmer.colony_elevation <- lmer(colony_elevation ~ Clusters + (1|Loc), data = metadata)
# Packages
library(tidyverse)
library(lme4)
library(emmeans)
library(emmeans)
library(lme4)
install.packages("lme4")
library(lme4)
install.packages("nloptr")
library(lme4)
remove.packages("nloptr")
install.packages("nloptr")
library(lme4)
install.packages("lme4")
library(lme4)
